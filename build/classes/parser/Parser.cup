/* Parser.cup */
package parser;

import java_cup.runtime.*;
import lexer.Lexer;
import java.util.List;
import java.util.ArrayList;
import java.util.Set;
import java.util.HashSet;
import simbolo.*;
import AST.*;
import expresiones.*;
import statements.*;
import errores.ManejadorErrores;
import errores.Error.TipoError;
import errores.ReturnException;

parser code {:
    public Parser(Lexer lexer) {
        super(lexer);
    }

    @Override
    public void syntax_error(Symbol s) {
        String lexema = "";
        if(s.value != null) {
            lexema = s.value.toString();
        } else if (s.sym >= 0 && s.sym < parser.sym.terminalNames.length) {
            lexema = parser.sym.terminalNames[s.sym];
        } else {
            lexema = "Token desconocido";
        }

        int linea = s.left;
        int columna = s.right;     
        String mensaje = "Error Sintáctico: No se esperaba el componente '" + lexema + "'";   
        ManejadorErrores.agregar(TipoError.SINTACTICO.toString(), mensaje, linea, columna);
    }

    @Override
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        String lexema = (s.value != null) ? s.value.toString() : "Token desconocido";
        int linea = s.left;
        int columna = s.right;
        String mensaje = "Error Sintáctico Fatal (Irrecuperable): Se detuvo en '" + lexema + "'";     
        ManejadorErrores.agregar(TipoError.SINTACTICO.toString(), mensaje, linea, columna);    
    }
    public List<Stmt> ast;
    public List<Stmt> getAST(){
            return this.ast;
    }
:};

action code {:
    // Helpers si luego los necesitas
:};

terminal INT, DOUBLE, BOOLEAN, CHAR, STRING;
terminal ENTERO, DECIMAL, CARACTER, CADENA;
terminal TRUE, FALSE;
terminal ID;

terminal PRINT, VAR;
terminal IF, ELSE, SWITCH, CASE, DEFAULT;
terminal WHILE, DO, FOR;
terminal BREAK, CONTINUE, RETURN, VOID, START;
terminal MAS, MENOS, POR, DIV, MOD, POT;
terminal INCREMENTO, DECREMENTO;
terminal UMENOS;
terminal IGUAL_IGUAL, DIFERENTE, MENOR_IGUAL, MAYOR_IGUAL, MENOR, MAYOR;
terminal AND, OR, NOT, XOR;
terminal IGUAL, PUNTO_COMA, DOS_PUNTOS, COMA;
terminal PAREN_A, PAREN_C, LLAVE_A, LLAVE_C, CORCH_A, CORCH_C;

terminal LIST, NEW, PUNTO;

non terminal List inicio, lista_sentencias;
non terminal Stmt sentencia;
non terminal Stmt if_stmt, switch_stmt, while_stmt, do_while_stmt, for_stmt;
non terminal Stmt break_stmt, continue_stmt;
non terminal Stmt metodo_decl, return_stmt, start_stmt;
non terminal List<Param> lista_params;
non terminal List<Expr> lista_argumentos;
non terminal List<Expr> lista_expresiones;
non terminal List<List<Expr>> lista_de_listas_expr;
non terminal List<CaseStmt> lista_casos;
non terminal Stmt declaracion_lista;
non terminal CaseStmt caso_item;
non terminal Stmt default_case;
non terminal Stmt for_init, for_update;
non terminal Stmt print_stmt, declaracion, asignacion, incremento, decremento;
non terminal Expr expr;
non terminal TipoDato tipo;

precedence left PUNTO;
precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NOT;
precedence left IGUAL_IGUAL, DIFERENTE, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left POR, DIV, MOD;
precedence nonassoc POT;
precedence right UMENOS;

start with inicio;

//Inicio
inicio ::=
    lista_sentencias:ls     {: parser.ast = ls; RESULT = ls; :}
    ;

lista_sentencias ::=
    lista_sentencias:ls sentencia:s
        {: 
           if (s != null) ls.add(s);
           RESULT = ls; 
        :}
    | /* VACIO */
        {: 
           RESULT = new ArrayList<>(); 
        :}
    ;

sentencia ::=
    print_stmt:p            {: RESULT = p; :} 
    | declaracion:d         {: RESULT = d; :}
    | metodo_decl:m         {: RESULT = m; :}
    | asignacion:a          {: RESULT = a; :}
    | incremento:i          {: RESULT = i; :}
    | decremento:dec        {: RESULT = dec; :}
    | if_stmt:ifs           {: RESULT = ifs; :}
    | switch_stmt:sw        {: RESULT = sw; :}
    | while_stmt:wh         {: RESULT = wh; :}
    | break_stmt:br         {: RESULT = br; :}
    | continue_stmt:ct      {: RESULT = ct; :}
    | for_stmt:f            {: RESULT = f; :}
    | do_while_stmt:dwh     {: RESULT = dwh; :}    
    | return_stmt:r         {: RESULT = r; :}
    | start_stmt:ss         {: RESULT = ss; :}
    | declaracion_lista:dl  {: RESULT = dl; :}   
    | expr:e PUNTO_COMA     {: RESULT = e; :}
    | VAR ID:id DOS_PUNTOS tipo:t CORCH_A CORCH_C IGUAL CORCH_A lista_expresiones:l CORCH_C PUNTO_COMA
        {: 
            RESULT = new VectorDeclStmt(id.toString(), t, l, idleft, idright); 
        :}
    | VAR ID:id DOS_PUNTOS tipo:t CORCH_A CORCH_C CORCH_A CORCH_C IGUAL CORCH_A lista_de_listas_expr:l CORCH_C PUNTO_COMA
        {: 
            RESULT = new Vector2DDeclStmt(id.toString(), t, l, idleft, idright); 
        :}
    | ID:id CORCH_A expr:idx CORCH_C IGUAL expr:val PUNTO_COMA
        {: 
            RESULT = new VectorAsigStmt(id.toString(), idx, val, idleft, idright); 
        :}
    | ID:id CORCH_A expr:idx1 CORCH_C CORCH_A expr:idx2 CORCH_C IGUAL expr:val PUNTO_COMA
        {: 
            RESULT = new Vector2DAsigStmt(id.toString(), idx1, idx2, val, idleft, idright); 
        :}
    | error:err PUNTO_COMA     
        {: 
            String msg = "Error Sintáctico: Instrucción mal formada. Se recuperó en ';'";
            System.err.println(msg);
            RESULT = null;
        :}
    | error:err LLAVE_C
        {: 
            String msg = "Error Sintáctico: Error en bloque de código. Se recuperó en '}'";
            System.err.println(msg);
            RESULT = null;
        :}
    ;

//Sentencias de Control

if_stmt ::=
    IF PAREN_A expr:e PAREN_C LLAVE_A lista_sentencias:l1 LLAVE_C 
        {: RESULT = new IfStmt(e, l1, null, eleft, eright); :}
    | IF PAREN_A expr:e PAREN_C LLAVE_A lista_sentencias:l1 LLAVE_C ELSE LLAVE_A lista_sentencias:l2 LLAVE_C
        {: RESULT = new IfStmt(e, l1, l2, eleft, eright);  :}
    | IF PAREN_A expr:e PAREN_C LLAVE_A lista_sentencias:l1 LLAVE_C ELSE if_stmt:l2
        {: 
            List<Stmt> bloqueElse = new ArrayList<>();
            bloqueElse.add(l2);
            RESULT = new IfStmt(e, l1, bloqueElse, eleft, eright);
        :}
    ;

switch_stmt ::=
    SWITCH PAREN_A expr:e PAREN_C LLAVE_A lista_casos:l LLAVE_C
        {:
            RESULT = new SwitchStmt(e, l, null, eleft, eright);
        :}
    | SWITCH PAREN_A expr:e PAREN_C LLAVE_A lista_casos:l default_case:d LLAVE_C
        {:
            RESULT = new SwitchStmt(e, l, d, eleft, eright);
        :}
    ;

lista_casos ::=
    lista_casos:l caso_item:c
        {:
            if (c != null) l.add(c);
            RESULT = l;
        :}
    | /* VACIO */
        {:
            RESULT = new ArrayList<CaseStmt>();
        :}
    ;

caso_item ::=
    CASE expr:e DOS_PUNTOS lista_sentencias:l
        {: 
            RESULT = new CaseStmt(e, l, eleft, eright);
        :}
    ;

default_case ::=
    DEFAULT DOS_PUNTOS lista_sentencias:l
        {: 
            RESULT = new CaseStmt(null, l, lleft, lright); 
        :}
    ;

while_stmt ::=
    WHILE PAREN_A expr:e PAREN_C LLAVE_A lista_sentencias:l LLAVE_C
        {:
            RESULT = new WhileStmt(e, l, eleft, eright);
        :}
    ;

do_while_stmt ::=
    DO:d LLAVE_A lista_sentencias:l LLAVE_C WHILE PAREN_A expr:e PAREN_C PUNTO_COMA
        {:
            RESULT = new DoWhileStmt(e, l, dleft, dright);
        :}
    ;

declaracion_lista ::=
    LIST MENOR tipo:t MAYOR ID:id IGUAL NEW LIST PAREN_A PAREN_C PUNTO_COMA
        {: 
            RESULT = new ListDeclStmt(t, id.toString(), idleft, idright); 
        :}
    ;

for_stmt ::=
    FOR:f PAREN_A for_init:init expr:cond PUNTO_COMA for_update:up PAREN_C LLAVE_A lista_sentencias:l LLAVE_C
        {:
            RESULT = new ForStmt(init, up, cond, l, fleft, fright);
        :}
    ;

for_init ::=
    declaracion:d   
        {: 
            RESULT = d; 
        :}
    | asignacion:a  
        {: 
            RESULT = a; 
        :}
    ;

for_update ::=
    ID:id INCREMENTO
        {:
            RESULT = new IncDecStmt(id.toString(), IncDecStmt.OpIncDec.INCREMENTO, idleft, idright); 
        :}
    | ID:id DECREMENTO
        {:
            RESULT = new IncDecStmt(id.toString(), IncDecStmt.OpIncDec.DECREMENTO, idleft, idright); 
        :}
    | ID:id IGUAL expr:e
        {:
            RESULT = new AsigStmt(id.toString(), e, idleft, idright); 
        :}
    ;

 break_stmt ::=
    BREAK:b PUNTO_COMA {: RESULT = new BreakStmt(bleft, bright); :}
    ;

 continue_stmt ::=
    CONTINUE:c PUNTO_COMA {: RESULT = new ContinueStmt(cleft, cright); :}
    ;

print_stmt ::=
    PRINT PAREN_A expr:e PAREN_C PUNTO_COMA
        {:
           RESULT = new PrintStmt(e, eleft, eright);
        :}
    ;

declaracion ::=
    VAR ID:nombre DOS_PUNTOS tipo:t IGUAL expr:e PUNTO_COMA
        {:
            RESULT = new VarDeclStmt(t, nombre.toString(), e, nombreleft, nombreright);
        :}
    |  VAR ID:nombre DOS_PUNTOS tipo:t PUNTO_COMA
        {:
            RESULT = new VarDeclStmt(t, nombre.toString(), nombreleft, nombreright);
        :}
    ;

metodo_decl ::= 
    tipo:t ID:id PAREN_A lista_params:p PAREN_C LLAVE_A lista_sentencias:l LLAVE_C
        {: 
            RESULT = new MethodDeclStmt(t, id.toString(), p, l, tleft, tright);    
        :}
    | VOID:v ID:id PAREN_A lista_params:p PAREN_C LLAVE_A lista_sentencias:l LLAVE_C
        {: 
            RESULT = new MethodDeclStmt(TipoDato.VOID, id.toString(), p, l, vleft, vright); 
        :}
    ;

lista_params ::= 
    lista_params:l COMA tipo:t ID:id  
        {: 
            l.add(new Param(t, id.toString())); 
            RESULT = l; 
        :}
    | tipo:t ID:id                      
        {: 
            List<Param> lp = new ArrayList<>(); 
            lp.add(new Param(t, id.toString())); 
            RESULT = lp; 
        :}
    | /* vacío */                        
        {: 
            RESULT = new ArrayList<Param>(); 
        :}
    ;

lista_argumentos ::=
    lista_argumentos:l COMA expr:e 
        {: 
            l.add(e); 
            RESULT = l;
        :}
    | expr:e                         
        {: 
            List<Expr> la = new ArrayList<>(); 
            la.add(e); RESULT = la; 
        :}
    | /* vacío */                    
        {: 
            RESULT = new ArrayList<Expr>(); 
        :}
    ;

return_stmt ::=
    RETURN:r PUNTO_COMA
        {: 
            RESULT = new ReturnStmt(null, rleft, rright); 
        :}
    | RETURN:r expr:e PUNTO_COMA
        {: 
            RESULT = new ReturnStmt(e, rleft, rright); 
        :}
    ;

start_stmt ::= 
    START:s ID:id PAREN_A lista_argumentos:la PAREN_C PUNTO_COMA
        {: 
            RESULT = new StartStmt(id.toString(), la, sleft, sright); 
        :}
    ;

asignacion ::=
    ID:nombre IGUAL expr:e PUNTO_COMA
        {:
            RESULT = new AsigStmt (nombre.toString(), e, eleft, eright);
        :}
    ;

incremento ::=
    ID:id INCREMENTO PUNTO_COMA
        {:
            RESULT = new IncDecStmt(id.toString(), IncDecStmt.OpIncDec.INCREMENTO, idleft, idright);
        :}
    ;

decremento ::=
    ID:id DECREMENTO PUNTO_COMA
        {:
            RESULT = new IncDecStmt(id.toString(), IncDecStmt.OpIncDec.DECREMENTO, idleft, idright);
        :}
    ;

tipo ::=
      INT       {: RESULT = TipoDato.ENTERO;   :}
    | DOUBLE    {: RESULT = TipoDato.DECIMAL;  :}
    | BOOLEAN   {: RESULT = TipoDato.BOOLEANO; :}
    | CHAR      {: RESULT = TipoDato.CARACTER; :}
    | STRING    {: RESULT = TipoDato.CADENA;   :}
    ;

expr ::=
    //Aritmeticas
      expr:e1 MAS expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.MAS, e1left, e2right);
        :}
    | expr:e1 MENOS expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.MENOS, e1left, e2right);
        :}
    | expr:e1 POR expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.POR, e1left, e2right);
        :}
    | expr:e1 DIV expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.DIV, e1left, e2right);
        :}
    | expr:e1 MOD expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.MOD, e1left, e2right);
        :}
    | expr:e1 POT expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.POT, e1left, e2right);
        :}

    //Unarias
    | PAREN_A tipo:t PAREN_C expr:e
        {:
            RESULT = new CastExpr (t, e, eleft, eright);
        :} %prec UMENOS
    | MENOS expr:e 
        {:
            RESULT = new NegacionExpr (e, eleft, eright);
        :} %prec UMENOS
    
    //Relacionales
    | expr:e1 IGUAL_IGUAL expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.IGUAL_IGUAL, e1left, e2right);
        :}
    | expr:e1 DIFERENTE expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.DIFERENTE, e1left, e2right);
        :}
    | expr:e1 MENOR expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.MENOR, e1left, e2right);
        :}
    | expr:e1 MENOR_IGUAL expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.MENOR_IGUAL, e1left, e2right);
        :}
    | expr:e1 MAYOR expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.MAYOR, e1left, e2right);
        :}
    | expr:e1 MAYOR_IGUAL expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.MAYOR_IGUAL, e1left, e2right);
        :}

    //Logicas
    | expr:e1 AND expr:e2 
        {:
            RESULT = new OpLogicosExpr(e1, e2, OpLogicosExpr.OpLog.AND, e1left, e2right);
        :}
    | expr:e1 OR expr:e2 
        {:
            RESULT = new OpLogicosExpr(e1, e2, OpLogicosExpr.OpLog.OR, e1left, e2right);
        :}
    | NOT expr:e1
        {:
            RESULT = new OpLogicosExpr(e1, OpLogicosExpr.OpLog.NOT, e1left, e1right);
        :} 
    | expr:e1 XOR expr:e2
        {:
            RESULT = new OpLogicosExpr(e1, e2, OpLogicosExpr.OpLog.XOR, e1left, e2right);
        :}

    //Primitivos
    | ENTERO:n
        {:
           int v = Integer.parseInt(n.toString());
           RESULT = new ValorExpr(TipoDato.ENTERO, v, nleft, nright);
        :}
    | DECIMAL:d
        {:
           double v = Double.parseDouble(d.toString());
           RESULT = new ValorExpr(TipoDato.DECIMAL, v, dleft, dright);
        :}
    | CADENA:s
        {:
           RESULT = new ValorExpr(TipoDato.CADENA, s.toString(),sleft, sright);
        :}
    | CARACTER:c
        {:
           char ch = c.toString().charAt(0);
           RESULT = new ValorExpr(TipoDato.CARACTER, ch, cleft, cright);
        :}
    | TRUE:t
        {:
           RESULT = new ValorExpr(TipoDato.BOOLEANO, true, tleft, tright);
        :}
    | FALSE:f
        {:
           RESULT = new ValorExpr(TipoDato.BOOLEANO, false, fleft, fright);
        :}
    | ID:i
        {:
           RESULT = new VariableExpr(i.toString(), ileft, iright);
        :}
    | PAREN_A expr:e PAREN_C
        {:
           RESULT = e;
        :}
    | ID:id PAREN_A lista_argumentos:la PAREN_C
        {: 
            RESULT = new CallExpr(id.toString(), la, idleft, idright); 
        :}
    | ID:id CORCH_A expr:idx CORCH_C
        {: 
            RESULT = new VectorAccessExpr(id.toString(), idx, idleft, idright); 
        :}
    | ID:id CORCH_A expr:idx1 CORCH_C CORCH_A expr:idx2 CORCH_C
        {: 
            RESULT = new Vector2DAccessExpr(id.toString(), idx1, idx2, idleft, idright); 
        :}
    | ID:id PUNTO ID:metodo PAREN_A lista_argumentos:la PAREN_C
        {: 
            RESULT = new MethodCallStmt(id.toString(), metodo.toString(), la, idleft, idright); 
        :}
    ;

lista_expresiones ::=
    lista_expresiones:l COMA expr:e  
        {: 
            l.add(e); 
            RESULT = l; 
        :}
    | expr:e                        
        {: 
            List<Expr> l = new ArrayList<>();
            l.add(e); RESULT = l; 
        :}
    | CORCH_A CORCH_C 
        {: 
            // Para manejar inicializaciones vacías []
            RESULT = new ArrayList<Expr>(); 
        :}
    ;

lista_de_listas_expr ::=
    lista_de_listas_expr:l COMA CORCH_A lista_expresiones:subL CORCH_C 
        {: 
            l.add(subL); 
            RESULT = l; 
        :}
    | CORCH_A lista_expresiones:subL CORCH_C 
        {: 
            List<List<Expr>> l = new ArrayList<>();     
            l.add(subL); RESULT = l; 
        :}
    ;