/* Parser.cup */
package parser;

import java_cup.runtime.*;
import lexer.Lexer;

import java.util.List;
import java.util.ArrayList;

import simbolo.*;
import AST.*;
import expresiones.*;
import statements.*;

parser code {:
    public Parser(Lexer lexer) {
        super(lexer);
    }

    @Override
    public void report_error(String message, Object info) {
        System.out.println("Error sint√°ctico: " + message);
    }
:};

action code {:
    // Helpers si luego los necesitas
:};

terminal INT, DOUBLE, BOOL, CHAR, STRING;
terminal TRUE, FALSE;
terminal PRINT;

terminal MAS, MENOS, POR, DIV, MOD, POT;
terminal IGUAL_IGUAL, DIFERENTE, MENOR_IGUAL, MAYOR_IGUAL, MENOR, MAYOR, IGUAL;
terminal AND, OR, NOT, XOR;
terminal INCREMENTO, DECREMENTO;

terminal PAREN_A, PAREN_C;
terminal PUNTO_COMA, DOS_PUNTOS;

terminal ENTERO, DECIMAL, BOOLEANO, CADENA, CARACTER;
terminal ID;
terminal VAR;
terminal UMENOS;

non terminal List inicio, lista_sentencias;
non terminal Stmt sentencia, print_stmt, declaracion, asignacion, incremento, decremento;
non terminal Expr expr;
non terminal TipoDato tipo;

precedence left OR;
precedence left AND;
precedence left XOR;
precedence right NOT;
precedence left IGUAL_IGUAL, DIFERENTE, MENOR, MENOR_IGUAL, MAYOR, MAYOR_IGUAL;
precedence left MAS, MENOS;
precedence left POR, DIV, MOD;
precedence nonassoc POT;
precedence right UMENOS;

start with inicio;

inicio ::=
    lista_sentencias:ls
        {: RESULT = ls; :}
    ;

//Lista Sentencias
lista_sentencias ::=
      lista_sentencias:ls sentencia:s
        {: 
           if (s != null) ls.add(s);
           RESULT = ls; 
        :}
    | /* VACIO */
        {: 
           RESULT = new ArrayList<>(); 
        :}
    ;

//Sentencia
sentencia ::=
    print_stmt:p    {: RESULT = p; :} 
    | declaracion:d {: RESULT = d; :}
    | asignacion:a  {: RESULT = a; :}
    | incremento:i  {: RESULT = i; :}
    | decremento:dec {: RESULT = dec; :}
    ;

//print
print_stmt ::=
    PRINT PAREN_A expr:e PAREN_C PUNTO_COMA
        {:
           RESULT = new PrintStmt(e, eleft, eright);
        :}
    ;

//Declaracion
declaracion ::=
    VAR ID:nombre DOS_PUNTOS tipo:t IGUAL expr:e PUNTO_COMA
        {:
            RESULT = new VarDeclStmt(t, nombre.toString(), e, nombreleft, nombreright);
        :}
    |  VAR ID:nombre DOS_PUNTOS tipo:t PUNTO_COMA
        {:
            RESULT = new VarDeclStmt(t, nombre.toString(), nombreleft, nombreright);
        :}
    ;

//Asignacion
asignacion ::=
    ID:nombre IGUAL expr:e PUNTO_COMA
        {:
            RESULT = new AsigStmt (nombre.toString(), e, eleft, eright);
        :}
    ;

//Incremento
incremento ::=
    ID:id INCREMENTO PUNTO_COMA
        {:
            RESULT = new IncDecStmt(id.toString(), IncDecStmt.OpIncDec.INCREMENTO, idleft, idright);
        :}
    ;

//Decremento
decremento ::=
    ID:id DECREMENTO PUNTO_COMA
        {:
            RESULT = new IncDecStmt(id.toString(), IncDecStmt.OpIncDec.DECREMENTO, idleft, idright);
        :}
    ;

tipo ::=
      INT    {: RESULT = TipoDato.ENTERO;   :}
    | DOUBLE {: RESULT = TipoDato.DECIMAL;  :}
    | BOOL   {: RESULT = TipoDato.BOOLEANO; :}
    | CHAR   {: RESULT = TipoDato.CARACTER; :}
    | STRING {: RESULT = TipoDato.CADENA;   :}
    ;

expr ::=
//Suma
      expr:e1 MAS expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.MAS, e1left, e2right);
        :}
//Resta
    | expr:e1 MENOS expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.MENOS, e1left, e2right);
        :}
//Multiplicacion
    | expr:e1 POR expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.POR, e1left, e2right);
        :}
//Division
    | expr:e1 DIV expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.DIV, e1left, e2right);
        :}
//Porcentaje
    | expr:e1 MOD expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.MOD, e1left, e2right);
        :}
//Potencia
    | expr:e1 POT expr:e2
        {:
           RESULT = new OpAritmeticosExpr(e1, e2, OpAritmeticosExpr.OpBin.POT, e1left, e2right);
        :}
//Agrupacion
    | PAREN_A expr:e PAREN_C
        {:
           RESULT = e;
        :}
//Igualacion
    | expr:e1 IGUAL_IGUAL expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.IGUAL_IGUAL, e1left, e2right);
        :}
//Diferenciacion
    | expr:e1 DIFERENTE expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.DIFERENTE, e1left, e2right);
        :}
//Menor Que
    | expr:e1 MENOR expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.MENOR, e1left, e2right);
        :}
//Menor Igual Que
    | expr:e1 MENOR_IGUAL expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.MENOR_IGUAL, e1left, e2right);
        :}
//Mayor Que
    | expr:e1 MAYOR expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.MAYOR, e1left, e2right);
        :}
//Mayor Igual Que
    | expr:e1 MAYOR_IGUAL expr:e2 
        {:
            RESULT = new OpRelacionalesExpr(e1, e2, OpRelacionalesExpr.OpRel.MAYOR_IGUAL, e1left, e2right);
        :}
//AND
    | expr:e1 AND expr:e2 
        {:
            RESULT = new OpLogicosExpr(e1, e2, OpLogicosExpr.OpLog.AND, e1left, e2right);
        :}
//OR
    | expr:e1 OR expr:e2 
        {:
            RESULT = new OpLogicosExpr(e1, e2, OpLogicosExpr.OpLog.OR, e1left, e2right);
        :}
//NOT
    | NOT expr:e1
        {:
            RESULT = new OpLogicosExpr(e1, OpLogicosExpr.OpLog.NOT, e1left, e1right);
        :}
    | ENTERO:n
        {:
           int v = Integer.parseInt(n.toString());
           RESULT = new ValorExpr(TipoDato.ENTERO, v, nleft, nright);
        :}
    | DECIMAL:d
        {:
           double v = Double.parseDouble(d.toString());
           RESULT = new ValorExpr(TipoDato.DECIMAL, v, dleft, dright);
        :}
    | CADENA:s
        {:
           RESULT = new ValorExpr(TipoDato.CADENA, s.toString(),sleft, sright);
        :}
    | CARACTER:c
        {:
           char ch = c.toString().charAt(0);
           RESULT = new ValorExpr(TipoDato.CARACTER, ch, cleft, cright);
        :}
    | TRUE:t
        {:
           RESULT = new ValorExpr(TipoDato.BOOLEANO, true, tleft, tright);
        :}
    | FALSE:f
        {:
           RESULT = new ValorExpr(TipoDato.BOOLEANO, false, fleft, fright);
        :}
    | ID:i
        {:
           RESULT = new VariableExpr(i.toString(), ileft, iright);
        :}
//Casteo
    | PAREN_A tipo:t PAREN_C expr:e
        {:
            RESULT = new CastExpr (t, e, eleft, eright);
        :} %prec UMENOS
//Negacion
    | MENOS expr:e 
        {:
            RESULT = new NegacionExpr (e, eleft, eright);
        :} %prec UMENOS
    ;
